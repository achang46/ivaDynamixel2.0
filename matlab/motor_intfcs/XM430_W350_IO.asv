%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Author:   Alex Chang (modification)
%           Chi Nnoka (original)
% Date: 10/06/2019
% This is a modified version of the Dynamixel_IO class that Alex Chang created for the RX-28 motors.
% This Dynamixel XM430 class is intended for the Dynamixel XM430-W350R motors.
%  WARNING  :  Do not set the motors baud rate over 3 million. 
%              USB-to-serial chipsets we currently use are limited to 
%              3 million baud; setting a higher baud rate may result in an
%              unrecoverable Dynamixel motor.
%              To be safe, stay on 1 million baud.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
classdef XM430_W350_IO < DXL_IO
  % This Class serves to organize the functions that command the new motors
  % Detailed explanation goes here

  properties (Access = protected)
    PROTOCOL_VERSION = 2.0;
    
    ANGLE_MIN = 0;          % min. achievable motor position (rad)
    ANGLE_MAX = 2*pi;       % max. achievable motor position (rad)
    ENC_BIT_LEN = 12;       % encoder count bit-length

    ENC_TO_RAD = 2*pi/(2^12-1);         % (rad/encoder cnts)
    ENC_HOME_POS = ceil((2^12-1)/2);   % Encoder count offset for zero rad. position
  end
  
  properties (Constant)
    % Dynamixel control table field addresses
    % ==== EEPROM Table ==== 
    ADDR_MODEL_NUMBER               = 0;
    ADDR_MODEL_INFORMATION          = 2;
    ADDR_FIRMWARE_VERSION           = 6;
    ADDR_ID                         = 7;
    ADDR_BAUD_RATE                  = 8;
    ADDR_RETURN_DELAY_TIME          = 9;
    ADDR_DRIVE_MODE                 = 10;
    ADDR_OPERATING_MODE             = 11;
    ADDR_SECONDARY_ID               = 12;
    ADDR_PROTOCOL_TYPE              = 13;
    ADDR_HOMING_OFFSET              = 20;
    ADDR_MOVING_THRESHOLD           = 24;
    ADDR_TEMPERATURE_LIMIT          = 31;
    ADDR_MAX_VOLTAGE_LIMIT          = 32;
    ADDR_MIN_VOLTAGE_LIMIT          = 34;
    ADDR_PWM_LIMIT                  = 36;
    ADDR_CURRENT_LIMIT              = 38;
    ADDR_VELOCITY_LIMIT             = 44;
    ADDR_MAX_POSITION_LIMIT         = 48;
    ADDR_MIN_POSITION_LIMIT         = 52;
    ADDR_STARTUP_CONFIGURATION      = 60;
    ADDR_SHUTDOWN                   = 63;
    % ==== RAM Table ==== 
    ADDR_TORQUE_ENABLE              = 64;
    ADDR_LED                        = 65;
    ADDR_STATUS_RETURN_LEVEL        = 68;
    ADDR_REGISTERED_INSTRUCTION     = 69;
    ADDR_HARDWARE_ERROR_STATUS      = 70;
    ADDR_VELOCITY_I_GAIN            = 76;
    ADDR_VELOCITY_P_GAIN            = 78;
    ADDR_POSITION_D_GAIN            = 80;
    ADDR_POSITION_I_GAIN            = 82;
    ADDR_POSITION_P_GAIN            = 84;
    ADDR_FEEDFORWARD_2ND_GAIN       = 88;
    ADDR_FEEDFORWARD_1ST_GAIN       = 90;
    ADDR_BUS_WATCHDOG               = 98;
    ADDR_GOAL_PWM                   = 100;
    ADDR_GOAL_CURRENT               = 102;
    ADDR_GOAL_VELOCITY              = 104;
    ADDR_PROFILE_ACCELERATION       = 108;
    ADDR_PROFILE_VELOCITY           = 112;
    ADDR_GOAL_POSITION              = 116;
    ADDR_REALTIME_TICK              = 120;
    ADDR_MOVING                     = 122;
    ADDR_MOVING_STATUS              = 123;
    ADDR_PRESENT_PWM                = 124;
    ADDR_PRESENT_CURRENT            = 126;
    ADDR_PRESENT_VELOCITY           = 128;
    ADDR_PRESENT_POSITION           = 132;
    ADDR_VELOCITY_TRAJECTORY        = 136;
    ADDR_POSITION_TRAJECTORY        = 140;
    ADDR_PRESENT_INPUT_VOLTAGE      = 144;
    ADDR_PRESENT_TEMPERATURE        = 146;
    ADDR_BACKUP_READY               = 147;
    
    ADDR_INDIRECT_ADDRESS_1          = 168;   % ADDR_INDIRECT_ADDRESS_1 ... ADDR_INDIRECT_ADDRESS_28 = 168:2:222
    ADDR_INDIRECT_DATA_1             = 224;   % ADDR_INDIRECT_DATA_1 ...   ADDR_INDIRECT_DATA_28 = 224:1:251

    ADDR_INDIRECT_ADDRESS_29         = 578;   % ADDR_INDIRECT_ADDRESS_29 ... ADDR_INDIRECT_ADDRESS_56 = 578:2:632
    ADDR_INDIRECT_DATA_29            = 634;   % ADDR_INDIRECT_DATA_29 ... ADDR_INDIRECT_DATA_56 = 634:1:661

    % Dynamixel control table field lengths
    % ==== EEPROM Table ==== 
    LEN_MODEL_NUMBER               = 2;
    LEN_MODEL_INFORMATION          = 4;
    LEN_FIRMWARE_VERSION           = 1;
    LEN_ID                         = 1;
    LEN_BAUD_RATE                  = 1;
    LEN_RETURN_DELAY_TIME          = 1;
    LEN_DRIVE_MODE                 = 1;
    LEN_OPERATING_MODE             = 1;
    LEN_SECONDARY_ID               = 1;
    LEN_PROTOCOL_TYPE              = 1;
    LEN_HOMING_OFFSET              = 4;
    LEN_MOVING_THRESHOLD           = 4;
    LEN_TEMPERATURE_LIMIT          = 1;
    LEN_MAX_VOLTAGE_LIMIT          = 2;
    LEN_MIN_VOLTAGE_LIMIT          = 2;
    LEN_PWM_LIMIT                  = 2;
    LEN_CURRENT_LIMIT              = 2;
    LEN_VELOCITY_LIMIT             = 4;
    LEN_MAX_POSITION_LIMIT         = 4;
    LEN_MIN_POSITION_LIMIT         = 4;
    LEN_STARTUP_CONFIGURATION      = 1;    
    LEN_SHUTDOWN                   = 1;
    % ==== RAM Table ==== 
    LEN_TORQUE_ENABLE              = 1;
    LEN_LED                        = 1;
    LEN_STATUS_RETURN_LEVEL        = 1;
    LEN_REGISTERED_INSTRUCTION     = 1;
    LEN_HARDWARE_ERROR_STATUS      = 1;
    LEN_VELOCITY_I_GAIN            = 2;
    LEN_VELOCITY_P_GAIN            = 2;
    LEN_POSITION_D_GAIN            = 2;
    LEN_POSITION_I_GAIN            = 2;
    LEN_POSITION_P_GAIN            = 2;
    LEN_FEEDFORWARD_2ND_GAIN       = 2;
    LEN_FEEDFORWARD_1ST_GAIN       = 2;
    LEN_BUS_WATCHDOG               = 1;
    LEN_GOAL_PWM                   = 2;
    LEN_GOAL_CURRENT               = 2;
    LEN_GOAL_VELOCITY              = 4;
    LEN_PROFILE_ACCELERATION       = 4;
    LEN_PROFILE_VELOCITY           = 4;
    LEN_GOAL_POSITION              = 4;
    LEN_REALTIME_TICK              = 2;
    LEN_MOVING                     = 1;
    LEN_MOVING_STATUS              = 1;
    LEN_PRESENT_PWM                = 2;
    LEN_PRESENT_CURRENT            = 2;
    LEN_PRESENT_VELOCITY           = 4;
    LEN_PRESENT_POSITION           = 4;
    LEN_VELOCITY_TRAJECTORY        = 4;
    LEN_POSITION_TRAJECTORY        = 4;
    LEN_PRESENT_INPUT_VOLTAGE      = 2;
    LEN_PRESENT_TEMPERATURE        = 1;
    LEN_BACKUP_READY               = 1;
  end
  
  methods  (Access = public)
    % Constructor & initialization
    function obj = XM430_W350_IO()
      
      obj@DXL_IO(); 
      
    end
    
    % TODO: motor calibration procedure (i.e. read motor bias)

    % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % EEPROM Area: Write/set methods
    % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Set motor ID
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_new_id:  vector of LED on/off values (1, 0)
    function set_id( obj, a_motor_ids, a_new_id )
      assert( (length(a_new_id) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_id()]: Incompatible input vector lengths!');
      
      obj.groupSyncWriteAddr( a_motor_ids, a_new_id, obj.ADDR_ID, obj.LEN_ID );
    end

    % Set motor baud rate
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_baud_rate:  vector of LED on/off values (1, 0)
    function set_baud_rate( obj, a_motor_ids, a_baud_rate )
      assert( (length(a_baud_rate) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_baud_rate()]: Incompatible input vector lengths!');
      
      obj.groupSyncWriteAddr( a_motor_ids, a_baud_rate, obj.ADDR_BAUD_RATE, obj.LEN_BAUD_RATE );
    end

    % Set motor return delay time
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_delay:  vector of delay times (0 - 508 usec)
    function set_return_delay_time( obj, a_motor_ids, a_delay )
      assert( (length(a_delay) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_return_delay_time()]: Incompatible input vector lengths!');
      
      delay_cnt = floor(a_delay*254/508);

      obj.groupSyncWriteAddr( a_motor_ids, delay_cnt, obj.ADDR_RETURN_DELAY_TIME, obj.LEN_RETURN_DELAY_TIME );
    end

    % Set motor drive mode flags
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_drive_mode_flag:  vector of drive mode flags (8-bit flag)
    function set_drive_mode( obj, a_motor_ids, a_drive_mode_flag )
      assert( (length(a_drive_mode_flag) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_drive_mode()]: Incompatible input vector lengths!');

      obj.groupSyncWriteAddr( a_motor_ids, a_drive_mode_flag, obj.ADDR_DRIVE_MODE, obj.LEN_DRIVE_MODE );
    end

    % Set motor operating mode value
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_oper_mode_value:  vector of operating mode values (0, 1, 3, 4, 5 or 16)
    function set_operating_mode( obj, a_motor_ids, a_oper_mode_value )
      assert( (length(a_oper_mode_value) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_operating_mode()]: Incompatible input vector lengths!');

      obj.groupSyncWriteAddr( a_motor_ids, a_oper_mode_value, obj.ADDR_OPERATING_MODE, obj.LEN_OPERATING_MODE );
    end

    % Set motor secondary ID
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_secondary_id:  vector of LED on/off values (1, 0)
    function set_secondary_id( obj, a_motor_ids, a_secondary_id )
      assert( (length(a_secondary_id) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_secondary_id()]: Incompatible input vector lengths!');
      
      obj.groupSyncWriteAddr( a_motor_ids, a_secondary_id, obj.ADDR_SECONDARY_ID, obj.LEN_SECONDARY_ID );
    end

    % Set motor communication protocol type
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_protocol_type:  vector of DXL communication protocol types (1 or 2)
    function set_comm_protocol( obj, a_motor_ids, a_protocol_type )
      assert( (length(a_protocol_type) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_comm_protocol()]: Incompatible input vector lengths!');
      
      obj.groupSyncWriteAddr( a_motor_ids, a_protocol_type, obj.ADDR_PROTOCOL_TYPE, obj.LEN_PROTOCOL_TYPE );
    end

    % Set motor homing offset
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_pos_offset:  vector of LED on/off values (1, 0)
    function set_homing_offset( obj, a_motor_ids, a_pos_offset )
      assert( (length(a_pos_offset) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_homing_offset()]: Incompatible input vector lengths!');
      
      obj.groupSyncWriteAddr( a_motor_ids, a_pos_offset, obj.ADDR_HOMING_OFFSET, obj.LEN_HOMING_OFFSET );
    end

    % Set motor moving threshold
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_speed_thresh:  vector of moving threshold speeds (0.0+ rad/sec)
    function set_moving_threshold( obj, a_motor_ids, a_speed_thresh )
      assert( (length(a_speed_thresh) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_moving_threshold()]: Incompatible input vector lengths!');
      
      speed_thresh_cnt = floor(a_speed_thresh/obj.ENC_TO_RAD);

      obj.groupSyncWriteAddr( a_motor_ids, speed_thresh_cnt, obj.ADDR_MOVING_THRESHOLD, obj.LEN_MOVING_THRESHOLD );
    end

    % Set motor temperature limit
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_temp_limit:  vector of temperature limits (0 - 100 deg C; increments of 1 deg)
    function set_temperature_limit( obj, a_motor_ids, a_temp_limit )
      assert( (length(a_temp_limit) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_temperature_limit()]: Incompatible input vector lengths!');
      
      obj.groupSyncWriteAddr( a_motor_ids, floor(a_temp_limit), obj.ADDR_TEMPERATURE_LIMIT, obj.LEN_TEMPERATURE_LIMIT );
    end

    % Set motor max. voltage limit
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_max_voltage:  vector of max. voltage limits (9.5 - 16.0 V)
    function set_max_voltage_limit( obj, a_motor_ids, a_max_voltage )
      assert( (length(a_max_voltage) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_max_voltage_limit()]: Incompatible input vector lengths!');
      
      max_voltage_cnt = floor(a_max_voltage*10);

      obj.groupSyncWriteAddr( a_motor_ids, max_voltage_cnt, obj.ADDR_MAX_VOLTAGE_LIMIT, obj.LEN_MAX_VOLTAGE_LIMIT );
    end

    % Set motor min. voltage limit
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_min_voltage:  vector of max. voltage limits (9.5 - 16.0 V)
    function set_min_voltage_limit( obj, a_motor_ids, a_min_voltage )
      assert( (length(a_min_voltage) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_min_voltage_limit()]: Incompatible input vector lengths!');
      
      min_voltage_cnt = floor(a_min_voltage*10);

      obj.groupSyncWriteAddr( a_motor_ids, min_voltage_cnt, obj.ADDR_MIN_VOLTAGE_LIMIT, obj.LEN_MIN_VOLTAGE_LIMIT );
    end

    % Set motor PWM duty cycle limit
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_duty_cycle_limit:  vector of PWM duty cycle limits (0 - 100%)
    function set_pwm_limit( obj, a_motor_ids, a_duty_cycle_limit )
      assert( (length(a_duty_cycle_limit) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_pwm_limit()]: Incompatible input vector lengths!');
      
      duty_cycle_limit_cnt = floor(a_duty_cycle_limit*855/100);

      obj.groupSyncWriteAddr( a_motor_ids, duty_cycle_limit_cnt, obj.ADDR_PWM_LIMIT, obj.LEN_PWM_LIMIT );
    end

    % Set motor current limit
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_current_limit:  vector of current limits (0 - 3209 mA)
    function set_current_limit( obj, a_motor_ids, a_current_limit )
      assert( (length(a_current_limit) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_current_limit()]: Incompatible input vector lengths!');
      
      current_limit_cnt = floor(a_current_limit/2.69);

      obj.groupSyncWriteAddr( a_motor_ids, current_limit_cnt, obj.ADDR_CURRENT_LIMIT, obj.LEN_CURRENT_LIMIT );
    end

    % Set motor velocity limit
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_vel_limit:  vector of velocity limit values (0 - 24 rad/sec)
    function set_velocity_limit( obj, a_motor_ids, a_vel_limit )
      assert( (length(a_vel_limit) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_velocity_limit()]: Incompatible input vector lengths!');
      
      vel_limit_cnt = floor(a_vel_limit/(0.229*2*pi/60));

      obj.groupSyncWriteAddr( a_motor_ids, vel_limit_cnt, obj.ADDR_VELOCITY_LIMIT, obj.LEN_VELOCITY_LIMIT );
    end

    % Set motor max. position limit
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_max_pos_limit:  vector of max. position limits (0 - 2*pi rad)
    function set_max_position_limit( obj, a_motor_ids, a_max_pos_limit )
      assert( (length(a_max_pos_limit) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_max_position_limit()]: Incompatible input vector lengths!');
      
      max_pos_limit_cnt = floor(a_max_pos_limit/obj.ENC_TO_RAD);

      obj.groupSyncWriteAddr( a_motor_ids, max_pos_limit_cnt, obj.ADDR_MAX_POSITION_LIMIT, obj.LEN_MAX_POSITION_LIMIT );
    end
    
    % Set motor min. position limit
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_min_pos_limit:  vector of min. position limits (0 - 2*pi rad)
    function set_min_position_limit( obj, a_motor_ids, a_min_pos_limit )
      assert( (length(a_min_pos_limit) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_min_position_limit()]: Incompatible input vector lengths!');
      
      min_pos_limit_cnt = floor(a_min_pos_limit/obj.ENC_TO_RAD);

      obj.groupSyncWriteAddr( a_motor_ids, min_pos_limit_cnt, obj.ADDR_MIN_POSITION_LIMIT, obj.LEN_MIN_POSITION_LIMIT );
    end

    % Set motor start-up configuration flags
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_startup_config_flags:  vector of start-up configuration flags (0 - 3; 8-bit flag)
    function set_startup_configuration( obj, a_motor_ids, a_startup_config_flags )
      assert( (length(a_startup_config_flags) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_startup_configuration()]: Incompatible input vector lengths!');
      
      obj.groupSyncWriteAddr( a_motor_ids, a_startup_config_flags, obj.ADDR_STARTUP_CONFIGURATION, obj.LEN_STARTUP_CONFIGURATION );
    end

    % Set motor shutdown condition flags
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_shutdown_cond_flags:  vector of shutdown configuration flags (8-bit flag)
    function set_shutdown_configuration( obj, a_motor_ids, a_shutdown_cond_flags )
      assert( (length(a_shutdown_cond_flags) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_shutdown_configuration()]: Incompatible input vector lengths!');
      
      obj.groupSyncWriteAddr( a_motor_ids, a_shutdown_cond_flags, obj.ADDR_SHUTDOWN, obj.LEN_SHUTDOWN );
    end


    % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % EEPROM Area: Read methods
    % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Read motor model number
    %
    % Input(s):
    %   a_motor_ids:      vector of motor IDs to read data from
    function [ result ] = get_model_number( obj, a_motor_ids )
      [ groupSyncReadData ] = obj.groupSyncReadAddr( a_motor_ids, obj.ADDR_MODEL_NUMBER, obj.LEN_MODEL_NUMBER);

      result = groupSyncReadData;
    end

    % Read motor model information
    %
    % Input(s):
    %   a_motor_ids:      vector of motor IDs to read data from
    function [ result ] = get_model_info( obj, a_motor_ids )
      [ groupSyncReadData ] = obj.groupSyncReadAddr( a_motor_ids, obj.ADDR_MODEL_INFORMATION, obj.LEN_MODEL_INFORMATION);

      result = groupSyncReadData;
    end

    % Read motor firmware version
    %
    % Input(s):
    %   a_motor_ids:      vector of motor IDs to read data from
    function [ result ] = get_firmware_ver( obj, a_motor_ids )
      [ groupSyncReadData ] = obj.groupSyncReadAddr( a_motor_ids, obj.ADDR_FIRMWARE_VERSION, obj.LEN_FIRMWARE_VERSION);

      result = groupSyncReadData;
    end

    % TODO: remaining read/get methods are non-urgent


    % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % RAM Area: Write/set methods
    % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Set motor torque enable
    %
    % Input(s):
    %   a_motor_ids:      vector of motor IDs to configure
    %   a_torque_enable:  vector of torque enable values (1, 0)
    function set_torque_enable( obj, a_motor_ids, a_torque_enable )
      assert( (length(a_torque_enable) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_torque_enable()]: Incompatible input vector lengths!');
      
      obj.groupSyncWriteAddr( a_motor_ids, a_torque_enable, obj.ADDR_TORQUE_ENABLE, obj.LEN_TORQUE_ENABLE );
    end

    % Set motor LED state
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_led_state:  vector of LED on/off values (1, 0)
    function set_led( obj, a_motor_ids, a_led_state )
      assert( (length(a_led_state) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_led()]: Incompatible input vector lengths!');
      
      obj.groupSyncWriteAddr( a_motor_ids, a_led_state, obj.ADDR_LED, obj.LEN_LED );
    end

    % Set motor status return level
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_status_return_level:  vector of LED on/off values (1, 0)
    function set_status_return_level( obj, a_motor_ids, a_status_return_level )
      assert( (length(a_status_return_level) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_status_return_level()]: Incompatible input vector lengths!');
      
      obj.groupSyncWriteAddr( a_motor_ids, a_status_return_level, obj.ADDR_STATUS_RETURN_LEVEL, obj.LEN_STATUS_RETURN_LEVEL );
    end

    % Set motor velocity I-gain
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_I_gain:  vector of LED on/off values (1, 0)
    function set_velocity_I_gain( obj, a_motor_ids, a_I_gain)
      assert( (length(a_I_gain) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_velocity_I_gain()]: Incompatible input vector lengths!');
      
      obj.groupSyncWriteAddr( a_motor_ids, a_I_gain, obj.ADDR_VELOCITY_I_GAIN, obj.LEN_VELOCITY_I_GAIN );
    end

    % Set motor velocity P-gain
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_P_gain:  vector of LED on/off values (1, 0)
    function set_velocity_P_gain( obj, a_motor_ids, a_P_gain)
      assert( (length(a_P_gain) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_velocity_P_gain()]: Incompatible input vector lengths!');
      
      obj.groupSyncWriteAddr( a_motor_ids, a_P_gain, obj.ADDR_VELOCITY_P_GAIN, obj.LEN_VELOCITY_P_GAIN );
    end

    % Set motor position D-gain
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_D_gain:  vector of LED on/off values (1, 0)
    function set_position_D_gain( obj, a_motor_ids, a_D_gain)
      assert( (length(a_D_gain) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_position_D_gain()]: Incompatible input vector lengths!');
      
      obj.groupSyncWriteAddr( a_motor_ids, a_D_gain, obj.ADDR_POSITION_D_GAIN, obj.LEN_POSITION_D_GAIN );
    end

    % Set motor position I-gain
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_I_gain:  vector of LED on/off values (1, 0)
    function set_position_I_gain( obj, a_motor_ids, a_I_gain)
      assert( (length(a_I_gain) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_position_I_gain()]: Incompatible input vector lengths!');
      
      obj.groupSyncWriteAddr( a_motor_ids, a_I_gain, obj.ADDR_POSITION_I_GAIN, obj.LEN_POSITION_I_GAIN );
    end

    % Set motor position P-gain
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_P_gain:  vector of LED on/off values (1, 0)
    function set_position_P_gain( obj, a_motor_ids, a_P_gain)
      assert( (length(a_P_gain) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_position_P_gain()]: Incompatible input vector lengths!');
      
      obj.groupSyncWriteAddr( a_motor_ids, a_P_gain, obj.ADDR_POSITION_P_GAIN, obj.LEN_POSITION_P_GAIN );
    end

    % Set motor feedforward 2nd gain
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_ff_2nd_gain:  vector of LED on/off values (1, 0)
    function set_feedforward_2nd_gain( obj, a_motor_ids, a_ff_2nd_gain)
      assert( (length(a_ff_2nd_gain) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_feedforward_2nd_gain()]: Incompatible input vector lengths!');
      
      obj.groupSyncWriteAddr( a_motor_ids, a_ff_2nd_gain, obj.ADDR_FEEDFORWARD_2ND_GAIN, obj.LEN_FEEDFORWARD_2ND_GAIN );
    end

    % Set motor feedforward 1st gain
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_ff_1st_gain:  vector of LED on/off values (1, 0)
    function set_feedforward_1st_gain( obj, a_motor_ids, a_ff_1st_gain)
      assert( (length(a_ff_1st_gain) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_feedforward_1st_gain()]: Incompatible input vector lengths!');
      
      obj.groupSyncWriteAddr( a_motor_ids, a_ff_1st_gain, obj.ADDR_FEEDFORWARD_1ST_GAIN, obj.LEN_FEEDFORWARD_1ST_GAIN );
    end

    % Set motor bus watchdog value
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_watchdog_inteval:  vector of LED on/off values (1, 0)
    function set_bus_watchdog( obj, a_motor_ids, a_watchdog_inteval)
      assert( (length(a_watchdog_inteval) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_bus_watchdog()]: Incompatible input vector lengths!');
      
      obj.groupSyncWriteAddr( a_motor_ids, a_watchdog_inteval, obj.ADDR_BUS_WATCHDOG, obj.LEN_BUS_WATCHDOG );
    end

    % Set motor goal PWM
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_pwm_duty_cycle:  vector of PWM duty cycle values (0 - 100%)
    function set_goal_pwm( obj, a_motor_ids, a_pwm_duty_cycle)
      assert( (length(a_pwm_duty_cycle) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_goal_pwm()]: Incompatible input vector lengths!');
      
      pwm__duty_cycle_cnt = floor(a_pwm_duty_cycle*885/100);
      
      obj.groupSyncWriteAddr( a_motor_ids, pwm__duty_cycle_cnt, obj.ADDR_GOAL_PWM, obj.LEN_GOAL_PWM );
    end

    % Set motor goal current
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_goal_current:  vector of LED on/off values (1, 0)
    function set_goal_current( obj, a_motor_ids, a_goal_current)
      assert( (length(a_goal_current) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_goal_current()]: Incompatible input vector lengths!');
      
      obj.groupSyncWriteAddr( a_motor_ids, a_goal_current, obj.ADDR_GOAL_CURRENT, obj.LEN_GOAL_CURRENT );
    end

    % Set motor goal velocity
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_goal_velocity:  vector of LED on/off values (1, 0)
    function set_goal_velocity( obj, a_motor_ids, a_goal_velocity)
      assert( (length(a_goal_velocity) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_goal_velocity()]: Incompatible input vector lengths!');
      
      obj.groupSyncWriteAddr( a_motor_ids, a_goal_velocity, obj.ADDR_GOAL_VELOCITY, obj.LEN_GOAL_VELOCITY );
    end

    % Set motor acceleration profile
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_accel_profile:  vector of LED on/off values (1, 0)
    function set_acceleration_profile( obj, a_motor_ids, a_accel_profile)
      assert( (length(a_accel_profile) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_acceleration_profile()]: Incompatible input vector lengths!');
      
      obj.groupSyncWriteAddr( a_motor_ids, a_accel_profile, obj.ADDR_PROFILE_ACCELERATION, obj.LEN_PROFILE_ACCELERATION );
    end

    % Set motor velocity profile
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_vel_profile:  vector of LED on/off values (1, 0)
    function set_velocity_profile( obj, a_motor_ids, a_vel_profile)
      assert( (length(a_vel_profile) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_velocity_profile()]: Incompatible input vector lengths!');
      
      obj.groupSyncWriteAddr( a_motor_ids, a_vel_profile, obj.ADDR_PROFILE_VELOCITY, obj.LEN_PROFILE_VELOCITY );
    end

    % Command motor goal positions
    %
    % Input(s):
    %   a_motor_ids:  vector of motor IDs to configure
    %   a_pos:  vector of position values (0 - 4095)
    function set_goal_pos( obj, a_motor_ids, a_pos )
      assert( (length(a_pos) == length(a_motor_ids) ), ...
              '[DXLIO_XM430_W350::set_goal_pos()]: Incompatible input vector lengths!');

      obj.groupSyncWriteAddr( a_motor_ids, a_pos, obj.ADDR_GOAL_POSITION, obj.LEN_GOAL_POSITION );
    end

    % TODO: method to set goal position & goal velocity simultaneously


    % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % RAM Area: Read methods
    % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Read/check whether instruction registered by REG_WRITE
    %
    % Input(s):
    %   a_motor_ids:      vector of motor IDs to read data from
    % 
    % Output(s):
    %   result:           boolean vector (0 or 1)    
    function [ result ] = is_instruction_registered( obj, a_motor_ids )
      [ groupSyncReadData ] = obj.groupSyncReadAddr( a_motor_ids, obj.ADDR_REGISTERED_INSTRUCTION, obj.LEN_REGISTERED_INSTRUCTION);

      result = groupSyncReadData;
    end

    % Read motor hardware error status (8-bit flags)
    %
    % Input(s):
    %   a_motor_ids:      vector of motor IDs to read data from
    % 
    % Output(s):
    %   result:           vector of 8-bit flags
    function [ result ] = get_hw_error_status( obj, a_motor_ids )
      [ groupSyncReadData ] = obj.groupSyncReadAddr( a_motor_ids, obj.ADDR_HARDWARE_ERROR_STATUS, obj.LEN_HARDWARE_ERROR_STATUS);

      result = groupSyncReadData;
    end

    % Read motor real-time tick
    %
    % Input(s):
    %   a_motor_ids:      vector of motor IDs to read data from
    % 
    % Output(s):
    %   result:           vector of reatime tick time (0 - 32767 ms)
    function [ result ] = get_realtime_tick( obj, a_motor_ids )
      [ groupSyncReadData ] = obj.groupSyncReadAddr( a_motor_ids, obj.ADDR_REALTIME_TICK, obj.LEN_REALTIME_TICK);

      result = groupSyncReadData;
    end

    % Check whether motor horn is moving
    %
    % Input(s):
    %   a_motor_ids:      vector of motor IDs to read data from
    % 
    % Output(s):
    %   result:           boolean vector (0 or 1; 1 = movement detected or movement profile in progress)
    function [ result ] = is_moving( obj, a_motor_ids )
      [ groupSyncReadData ] = obj.groupSyncReadAddr( a_motor_ids, obj.ADDR_MOVING, obj.LEN_MOVING);

      result = groupSyncReadData;
    end

    % Read motor real-time tick
    %
    % Input(s):
    %   a_motor_ids:      vector of motor IDs to read data from
    % 
    % Output(s):
    %   result:           vector of reatime tick time (0 - 32767 ms)
    function [ result ] = get_realtime_tick( obj, a_motor_ids )
      [ groupSyncReadData ] = obj.groupSyncReadAddr( a_motor_ids, obj.ADDR_MOVING_STATUS, obj.ADDR_MOVING_STATUS);

      result = groupSyncReadData;
    end
    
    
    
    
    
    
    
    % Simultaneously set (SYNC_WRITE) Torque Limit
    %
    % Input(s):
    %   motor_ids - n-vector of motor IDs to configure
    %   torque_limit - n-vector of torque limit values (0-100%)
    function comm_status = set_torque_limit( obj, motor_ids, torque_limit )
      assert( (size(torque_limit, 1) == length(motor_ids) ), 'Size mismatch: torque_limit and motor_ids!');
      
      torque_limit = torque_limit/100*1023;
      
      data = zeros( length(motor_ids), 2 );
      for index = 1:length(motor_ids)
        data(index, 1) = calllib(obj.lib_name,'dxl_get_lowbyte', int32(torque_limit(index)));
        data(index, 2) = calllib(obj.lib_name,'dxl_get_highbyte', int32(torque_limit(index)));
      end
      
      comm_status = obj.dxl_sync_write( motor_ids, obj.P_TORQUE_LIM, data );
    end
    
    % Simultaneously set (SYNC_WRITE) Max. Torque
    %
    % Input(s):
    %   motor_ids - n-vector of motor IDs to configure
    %   max_torque - n-vector of max. torque values (0-100%)
    
    function comm_status = set_max_torque( obj, motor_ids, max_torque )
      assert( (size(max_torque, 1) == length(motor_ids) ), 'Size mismatch: max_torque and motor_ids!');
      
      max_torque = max_torque/100*1023;
      
      data = zeros( length(motor_ids), 2 );
      for index = 1:length(motor_ids)
        data(index, 1) = calllib(obj.lib_name,'dxl_get_lowbyte', int32(max_torque(index)));
        data(index, 2) = calllib(obj.lib_name,'dxl_get_highbyte', int32(max_torque(index)));
      end
      
      comm_status = obj.dxl_sync_write( motor_ids, obj.P_MAX_TORQUE, data );
    end
    
    % Simultaneously set (SYNC_WRITE) voltage limit
    %
    % Input(s):
    %   motor_ids - n-vector of motor IDs to configure
    %   voltage_limit - n-vector of voltage limit values (5-25)
    %   limit_type - 'low', 'high'
    
    function comm_status = set_voltage_limit( obj, motor_ids, voltage_limit, limit_type )
      assert( (size(voltage_limit, 1) == length(motor_ids) ), 'Size mismatch: voltage_limit and motor_ids!');
      
      voltage_limit = int32(voltage_limit*10);
      
      if ( exist('limit_type', 'var') )
        if ( strcmp(limit_type, 'low') )
          comm_status = obj.dxl_sync_write( motor_ids, obj.P_VOLT_LIM_LOW, voltage_limit );
        elseif ( strcmp(limit_type, 'high') )
          comm_status = obj.dxl_sync_write( motor_ids, obj.P_VOLT_LIM_HIGH, voltage_limit );
        else
          error('Dynamixel_XM430::set_voltage_limit() - Invaid input value for limit_type!');
        end
      else
        comm_status = obj.dxl_sync_write( motor_ids, obj.P_VOLT_LIM_LOW, voltage_limit );
      end
    end
    
    % Simultaneously set (SYNC_WRITE) highest temperature limit
    %
    % Input(s):
    %   motor_ids - n-vector of motor IDs to configure
    %   temp_limit - n-vector of voltage_limit values (default 80 deg. C)
    
    function comm_status = set_temp_limit( obj, motor_ids, temp_limit )
      assert( (size(temp_limit, 1) == length(motor_ids) ), 'Size mismatch: temp_limit and motor_ids!');
      
      comm_status = obj.dxl_sync_write( motor_ids, obj.P_TEMP_LIM, int32(temp_limit) );
    end
    
    % Simultaneously set (SYNC_WRITE) new motor IDs
    %
    % Input(s):
    %   motor_ids - n-vector of motor IDs to configure
    %   alarm_shutdown_conf - n-vector of new motor ID values (0-252)
    
    % Simultaneously set (SYNC_WRITE) joint angle lmits (cw and/or ccw)
    %
    % Input(s):
    %   motor_ids - n-vector of motor IDs to configure
    %   angle_limit - n-vector of joint angle limit values (radian equivalent of -150 to 149.7070 degrees)
    %   limit_type - 'cw', 'ccw'
    function comm_status = set_angle_limit( obj, motor_ids, angle_limit, direction )
      assert( (size(angle_limit, 1) == length(motor_ids) ), 'Size mismatch: angle_limit and motor_ids!');
      
      angle_limit = obj.rad_to_pos_cnt(angle_limit);
      
      data = zeros( length(motor_ids), 2*size(angle_limit, 2) );
      for index = 1:length(motor_ids)
        data(index, 1) = calllib(obj.lib_name,'dxl_get_lowbyte', int32(angle_limit(index, 1)));
        data(index, 2) = calllib(obj.lib_name,'dxl_get_highbyte', int32(angle_limit(index, 1)));
        if ( size(angle_limit, 2) > 1 )
          data(index, 3) = calllib(obj.lib_name,'dxl_get_lowbyte', int32(angle_limit(index, 2)));
          data(index, 4) = calllib(obj.lib_name,'dxl_get_highbyte', int32(angle_limit(index, 2)));
        end
      end
      
      if ( exist('direction', 'var') )
        if ( strcmp(direction, 'cw') )
          comm_status = obj.dxl_sync_write( motor_ids, obj.P_CW_ANGLE_LIM, data );
        elseif ( strcmp(direction, 'ccw') )
          comm_status = obj.dxl_sync_write( motor_ids, obj.P_CCW_ANGLE_LIM, data );
        else
          error('Dynamixel_XM430::set_angle_limit() - Invaid input value for direction!');
        end
      else
        comm_status = obj.dxl_sync_write( motor_ids, obj.P_CW_ANGLE_LIM, data );
      end
    end
    
    % Simultaneously set (SYNC_WRITE) alarm ADDR_LED
    %
    % Input(s):
    %   motor_ids - n-vector of motor IDs to configure
    %   alarm_led_conf - n-vector of alarm ADDR_LED enable/disable values (byte flag)
    
    function comm_status = set_alarm_led( obj, motor_ids, alarm_led_conf )
      assert( (size(alarm_led_conf, 1) == length(motor_ids) ), 'Size mismatch: alarm_led_conf and motor_ids!');
      
      comm_status = obj.dxl_sync_write( motor_ids, obj.P_ALARM_ADDR_LED, alarm_led_conf );
    end
    
    % Simultaneously set (SYNC_WRITE) alarm shutdown
    %
    % Input(s):
    %   motor_ids - n-vector of motor IDs to configure
    %   alarm_shutdown_conf - n-vector of alarm shutdown enable/disable values (byte flag)
    
    function comm_status = set_alarm_shutdown( obj, motor_ids, alarm_shutdown_conf )
      assert( (size(alarm_shutdown_conf, 1) == length(motor_ids) ), 'Size mismatch: alarm_shutdown_conf and motor_ids!');
      
      comm_status = obj.dxl_sync_write( motor_ids, obj.P_ALARM_ADDR_SHUTDOWN, alarm_shutdown_conf );
    end
    
    function comm_status = set_id( obj, motor_ids, new_id )
      assert( (size(new_id, 1) == length(motor_ids) ), 'Size mismatch: new_id and motor_ids!');
      
      comm_status = obj.dxl_sync_write( motor_ids, obj.P_ID, new_id );
    end
    
    % Retrieve motor moving status
    %
    % Input(s):
    %   motor_ids - n-vector of motor IDs to read from
    %   print_results - 1, 0 (do, don't print string-formatted results)
    %
    % Output(s):
    %   result - n-vector of motor moving status values (1, 0)
    
    function result = is_moving( obj, motor_ids, print_results )
      result = obj.dxl_read_register( motor_ids, obj.P_ADDR_MOVING, 1, 0 );
      
      if ( print_results )
        for motor_index = 1:length(motor_ids)
          fprintf(1, 'Motor ID: %d is moving: %d\n', motor_ids(motor_index), result(motor_index));
        end
      end
    end
    
    % Retrieve motor temperature
    %
    % Input(s):
    %   motor_ids - n-vector of motor IDs to read from
    %   print_results - 1, 0 (do, don't print string-formatted results)
    %
    % Output(s):
    %   result - n-vector of motor temperature (deg. C)
    
    function result = read_present_temp( obj, motor_ids, print_results )
      result = obj.dxl_read_register( motor_ids, obj.P_PRESENT_TEMP, 1, 0 );
      
      if ( print_results )
        for motor_index = 1:length(motor_ids)
          fprintf(1, 'Motor ID: %d present temp.: %d deg. C\n', motor_ids(motor_index), result(motor_index));
        end
      end
    end
    
    % Retrieve present (input) motor voltage
    %
    % Input(s):
    %   motor_ids - n-vector of motor IDs to read from
    %   print_results - 1, 0 (do, don't print string-formatted results)
    %
    % Output(s):
    %   result - n-vector of motor voltage (V)
    
    function result = read_present_volt( obj, motor_ids, print_results )
      result = double(obj.dxl_read_register( motor_ids, obj.P_PRESENT_VOLTAGE, 1, 0 ))/10;
      
      if ( print_results )
        for motor_index = 1:length(motor_ids)
          fprintf(1, 'Motor ID: %d present volt.: %.2f V\n', motor_ids(motor_index), result(motor_index));
        end
      end
    end
    
    % Retrieve motor load
    %
    % Input(s):
    %   motor_ids - n-vector of motor IDs to read from
    %   print_results - 1, 0 (do, don't print string-formatted results)
    %
    % Output(s):
    %   result - n-vector of motor load (%)
    function result = read_present_load( obj, motor_ids, print_results )
      result = obj.load_cnt_to_percent(double(obj.dxl_read_register( motor_ids, obj.P_PRESENT_LOAD, 2, 0 )));
      
      if ( print_results )
        for motor_index = 1:length(motor_ids)
          fprintf(1, 'Motor ID: %d present load = %.2f perc.\n', motor_ids(motor_index), result(motor_index));
        end
      end
    end
    
    % Retrieve motor position and/or speed
    %
    % Input(s):
    %   motor_ids - n-vector of motor IDs to read from
    %   print_results - 1, 0 (do, don't print string-formatted results)
    %   type - 'pos', 'speed' (or optionally not specified)
    %
    % Output(s):
    %   result -
    %       if type = 'pos' or 'speed': n-vector of motor pos or speed (rad or rad/s)
    %       if type not specified: n-by-2 matrix of motor pos (col. 1) and speed (col. 2)
    function result = read_present_pos_vel( obj, motor_ids, print_results, joint_bias, type )
      if ( isempty(joint_bias) )
        joint_bias = zeros(length(motor_ids), 1);
      else
        assert(length(joint_bias) == length(motor_ids), ...
          'Dynamixel_XM430::read_present_pos_vel(): Error --> joint_bias, motor_ids length mismatch!');
        joint_bias = int32(joint_bias);
      end
      
      if ( exist('type', 'var') )
        if ( strcmp(type, 'pos') )
          raw_enc_pos = obj.dxl_read_register( motor_ids, obj.P_ADDR_PRESENT_POSITION, 2, 0 );
          result = obj.pos_cnt_to_rad(raw_enc_pos + double(joint_bias));
        elseif ( strcmp(type, 'speed') )
          result = obj.vel_cnt_to_rad_s(double(obj.dxl_read_register( motor_ids, obj.P_PRESENT_SPEED, 2, 0 )));
        end
      else
        result = obj.dxl_read_register( motor_ids, [ obj.P_ADDR_PRESENT_POSITION, obj.P_PRESENT_SPEED ], [ 2, 2 ], 0 );
        result(:, 1) = obj.pos_cnt_to_rad(result(:, 1) + double(joint_bias));
        result(:, 2) = obj.vel_cnt_to_rad_s(double(result(:, 2)));
      end
      
      if ( print_results )
        for motor_index = 1:length(motor_ids)
          if ( exist('type', 'var') )
            fprintf(1, 'Motor ID: %d present %s: %.4f rad or rad/s\n', motor_ids(motor_index), type, result(motor_index, 1));
          else
            fprintf(1, 'Motor ID: %d present %s: %.4f rad\n', motor_ids(motor_index), 'pos', result(motor_index, 1));
            fprintf(1, 'Motor ID: %d present %s: %.4f rad/s\n', motor_ids(motor_index), 'speed', result(motor_index, 2));
          end
        end
      end
    end
    
    % Retrieve motor information
    %
    % Input(s):
    %   motor_ids - n-vector of motor IDs to read from
    %   print_results - 1, 0 (do, don't print string-formatted results)
    %
    % Output(s):
    %   result - n-by-4 matrix of motor information (model #, firmware
    %            ver., motor ID, motor baud rate)
    function result = read_motor_info( obj, motor_ids, print_results )
      result = obj.dxl_read_register( motor_ids, [ obj.P_ADDR_MODEL_NUMBER, obj.P_FIRMWARE, obj.P_ID, obj.P_ADDR_BAUD_RATE ], ...
        [2, 1, 1, 1], 0 );
      
      if ( print_results )
        for motor_index = 1:length(motor_ids)
          fprintf(1, 'Motor ID: %d - \n\t Model Number: %d \n\t Firmware Version: %d \n\t Baud Rate: %d \n\n', ...
            result(motor_index, 3), result(motor_index, 1), result(motor_index, 2), result(motor_index, 4));
        end
      end
    end
    
    % Retrieve motor alarm ADDR_LED enabled/disabled status
    %
    % Input(s):
    %   motor_ids - n-vector of motor IDs to read from
    %   print_results - 1, 0 (do, don't print string-formatted results)
    %
    % Output(s):
    %   result - n-vector of motor alarm ADDR_LED enabled/disabled status (byte flag)
    function result = read_alarm_led( obj, motor_ids, print_results )
      result = obj.dxl_read_register( motor_ids, obj.P_ALARM_ADDR_LED, 1, 0 );
      
      if ( print_results )
        for motor_index = 1:length(motor_ids)
          fprintf(1, 'Motor ID: %d alarm ADDR_LED config.: %d\n', motor_ids(motor_index), result(motor_index));
          msg = [ 'Input Voltage Error: ' int2str(bitand(result(motor_index), 1)>0) '\nAngle Limit Error: ' int2str(bitand(result(motor_index), 2)>0) ...
            '\nOverHeating Error: ' int2str(bitand(result(motor_index), 4)>0) '\nRange Error: ' int2str(bitand(result(motor_index), 8)>0) ...
            '\nCheckSum Error: ' int2str(bitand(result(motor_index), 16)>0) '\nOverload Error: ' int2str(bitand(result(motor_index), 32)>0) ...
            '\nInstruction Error: ' int2str(bitand(result(motor_index), 64)>0) '\n\n' ];
          fprintf( 1, msg );
        end
      end
    end
    
    % Retrieve motor alarm shutdown enabled/disabled status
    %
    % Input(s):
    %   motor_ids - n-vector of motor IDs to read from
    %   print_results - 1, 0 (do, don't print string-formatted results)
    %
    % Output(s):
    %   result - n-vector of motor alarm shutdown enabled/disabled status (byte flag)
    function result = read_alarm_shutdown( obj, motor_ids, print_results )
      result = obj.dxl_read_register( motor_ids, obj.P_ALARM_ADDR_SHUTDOWN, 1, 0 );
      
      if ( print_results )
        for motor_index = 1:length(motor_ids)
          fprintf(1, 'Motor ID: %d alarm shutdown config.: %d\n', motor_ids(motor_index), result(motor_index));
          msg = [ 'Input Voltage Error: ' int2str(bitand(result(motor_index), 1)>0) '\nAngle Limit Error: ' int2str(bitand(result(motor_index), 2)>0) ...
            '\nOverHeating Error: ' int2str(bitand(result(motor_index), 4)>0) '\nRange Error: ' int2str(bitand(result(motor_index), 8)>0) ...
            '\nCheckSum Error: ' int2str(bitand(result(motor_index), 16)>0) '\nOverload Error: ' int2str(bitand(result(motor_index), 32)>0) ...
            '\nInstruction Error: ' int2str(bitand(result(motor_index), 64)>0) '\n\n' ];
          fprintf( 1, msg );
        end
      end
    end
    
    % Retrieve motor torque limit
    %
    % Input(s):
    %   motor_ids - n-vector of motor IDs to read from
    %   print_results - 1, 0 (do, don't print string-formatted results)
    %
    % Output(s):
    %   result - n-vector of motor torque limits (%)
    function result = read_torque_limit( obj, motor_ids, print_results )
      result = double(obj.dxl_read_register( motor_ids, obj.P_TORQUE_LIM, 2, 0 ))/1023*100;
      
      if ( print_results )
        for motor_index = 1:length(motor_ids)
          fprintf(1, 'Motor ID: %d torque limit: %.2f perc.\n', motor_ids(motor_index), result(motor_index));
        end
      end
    end
    
    % Retrieve motor max. torque
    %
    % Input(s):
    %   motor_ids - n-vector of motor IDs to read from
    %   print_results - 1, 0 (do, don't print string-formatted results)
    %
    % Output(s):
    %   result - n-vector of motor max. torque values (%)
    function result = read_max_torque( obj, motor_ids, print_results )
      result = double(obj.dxl_read_register( motor_ids, obj.P_MAX_TORQUE, 2, 0 ))/1023*100;
      
      if ( print_results )
        for motor_index = 1:length(motor_ids)
          fprintf(1, 'Motor ID: %d max. torque: %.2f perc.\n', motor_ids(motor_index), result(motor_index));
        end
      end
    end
    
    % Retrieve motor angle limit(s)
    %
    % Input(s):
    %   motor_ids - n-vector of motor IDs to read from
    %   print_results - 1, 0 (do, don't print string-formatted results)
    %   direction - 'cw', 'ccw' (or optionally not specified)
    %
    % Output(s):
    %   result -
    %       if direction = 'cw' or 'ccw': n-vector of motor cw or ccw angle limit (rad)
    %       if direction not specified: n-by-2 matrix of motor cw (col. 1) and ccw (col. 2) angle limits
    function result = read_angle_limit( obj, motor_ids, print_results, direction )
      if ( exist('direction', 'var') )
        if ( strcmp(direction, 'cw') )
          result = obj.pos_cnt_to_rad(double(obj.dxl_read_register( motor_ids, obj.P_CW_ANGLE_LIM, 2, 0 )));
        elseif ( strcmp(direction, 'ccw') )
          result = obj.pos_cnt_to_rad(double(obj.dxl_read_register( motor_ids, obj.P_CCW_ANGLE_LIM, 2, 0 )));
        end
      else
        result = obj.pos_cnt_to_rad(double(obj.dxl_read_register( motor_ids, [ obj.P_CW_ANGLE_LIM, obj.P_CCW_ANGLE_LIM ], [ 2, 2 ], 0 )));
      end
      
      if ( print_results )
        for motor_index = 1:length(motor_ids)
          if ( exist('direction', 'var') )
            fprintf(1, 'Motor ID: %d angle limit (%s): %.2f rad\n', motor_ids(motor_index), direction, result(motor_index, 1));
          else
            fprintf(1, 'Motor ID: %d angle limit (%s): %.2f rad\n', motor_ids(motor_index), 'cw', result(motor_index, 1));
            fprintf(1, 'Motor ID: %d angle limit (%s): %.2f rad\n', motor_ids(motor_index), 'ccw', result(motor_index, 2));
          end
        end
      end
    end
    
    % Retrieve motor voltage limit(s)
    %
    % Input(s):
    %   motor_ids - n-vector of motor IDs to read from
    %   print_results - 1, 0 (do, don't print string-formatted results)
    %   limit_type - 'low', 'high' (or optionally not specified)
    %
    % Output(s):
    %   result -
    %       if limit_type = 'low' or 'high' n-vector of motor low or high voltage limit (V)
    %       if limit_type not specified: n-by-2 matrix of motor low (col. 1) and high (col. 2) voltage limits (rad)
    
    function result = read_voltage_limit( obj, motor_ids, print_results, limit_type )
      if ( exist('limit_type', 'var') )
        if ( strcmp(limit_type, 'low') )
          result = double(obj.dxl_read_register( motor_ids, obj.P_VOLT_LIM_LOW, 1, 0 ))*0.1;
        elseif ( strcmp(limit_type, 'high') )
          result = double(obj.dxl_read_register( motor_ids, obj.P_VOLT_LIM_HIGH, 1, 0 ))*0.1;
        end
      else
        result = double(obj.dxl_read_register( motor_ids, [ obj.P_VOLT_LIM_LOW, obj.P_VOLT_LIM_HIGH ], [ 1, 1 ], 0 ))*0.1;
      end
      
      if ( print_results )
        for motor_index = 1:length(motor_ids)
          if ( exist('limit_type', 'var') )
            fprintf(1, 'Motor ID: %d voltage limit (%s): %.2f V\n', motor_ids(motor_index), limit_type, result(motor_index, 1));
          else
            fprintf(1, 'Motor ID: %d voltage limit (%s): %.2f V\n', motor_ids(motor_index), 'low', result(motor_index, 1));
            fprintf(1, 'Motor ID: %d voltage limit (%s): %.2f V\n', motor_ids(motor_index), 'high', result(motor_index, 2));
          end
        end
      end
    end
    
    %     % Retrieve motor position and/or speed
    %
    % Input(s):
    %   motor_ids - n-vector of motor IDs to read from
    %   print_results - 1, 0 (do, don't print string-formatted results)
    %   type - 'pos', 'speed' (or optionally not specified)
    %
    % Output(s):
    %   result -
    %       if type = 'pos' or 'speed' n-vector of motor position or speed values (rad or rad/s)
    %       if type not specified: n-by-2 matrix of motor position (col. 1) and speed (col. 2) values (rad and rad/s)
    
    function result = read_goal_pos_speed( obj, motor_ids, print_results, type )
      if ( exist('type', 'var') )
        if ( strcmp(type, 'pos') )
          result = obj.pos_cnt_to_rad(double(obj.dxl_read_register( motor_ids, obj.P_ADDR_GOAL_POSITION, 2, 0 )));
        elseif ( strcmp(type, 'speed') )
          result = obj.vel_cnt_to_rad_s(double(obj.dxl_read_register( motor_ids, obj.P_ADDR_MOVING_SPEED, 2, 0 )));
        end
      else
        result = obj.dxl_read_register( motor_ids, [ obj.P_ADDR_GOAL_POSITION, obj.P_ADDR_MOVING_SPEED ], [ 2, 2 ], 0 );
        result(:, 1) = obj.pos_cnt_to_rad(double(result(:, 1)));
        result(:, 2) = obj.vel_cnt_to_rad_s(double(result(:, 2)));
      end
      
      if ( print_results )
        for motor_index = 1:length(motor_ids)
          if ( exist('type', 'var') )
            fprintf(1, 'Motor ID: %d goal %s: %.2f rad or rad/s\n', motor_ids(motor_index), type, result(motor_index, 1));
          else
            fprintf(1, 'Motor ID: %d goal %s: %.2f rad\n', motor_ids(motor_index), 'pos', result(motor_index, 1));
            fprintf(1, 'Motor ID: %d goal %s: %.2f rad/s\n', motor_ids(motor_index), 'speed', result(motor_index, 2));
          end
        end
      end
    end
    
    % Retrieve motor torque enable status
    %
    % Input(s):
    %   motor_ids - n-vector of motor IDs to read from
    %   print_results - 1, 0 (do, don't print string-formatted results)
    %
    % Output(s):
    %   result - n-vector of motor torque enabled values (1, 0)
    
    function result = read_torque_enable( obj, motor_ids, print_results )
      result = obj.dxl_read_register( motor_ids, obj.P_ADDR_TORQUE_ENABLE, 1, 0 );
      
      if ( print_results )
        for motor_index = 1:length(motor_ids)
          fprintf(1, 'Motor ID: %d torque enable: %d\n', motor_ids(motor_index), result(motor_index));
        end
      end
    end
    
    % Retrieve motor ADDR_LED on/off status
    %
    % Input(s):
    %   motor_ids - n-vector of motor IDs to read from
    %   print_results - 1, 0 (do, don't print string-formatted results)
    %
    % Output(s):
    %   result - n-vector of motor ADDR_LED on/off values (1, 0)
    function result = read_led( obj, motor_ids, print_results )
      result = obj.dxl_read_register( motor_ids, obj.P_ADDR_LED_ON, 1, 0 );
      
      if ( print_results )
        for motor_index = 1:length(motor_ids)
          fprintf(1, 'Motor ID: %d ADDR_LED on: %d\n', motor_ids(motor_index), result(motor_index));
        end
      end
    end
    
    % Retrieve motor temperature limit
    %
    % Input(s):
    %   motor_ids - n-vector of motor IDs to read from
    %   print_results - 1, 0 (do, don't print string-formatted results)
    %
    % Output(s):
    %   result - n-vector of motor temperature limits (deg. C)
    function result = read_temp_limit( obj, motor_ids, print_results )
      result = obj.dxl_read_register( motor_ids, obj.P_TEMP_LIM, 1, 0 );
      
      if ( print_results )
        for motor_index = 1:length(motor_ids)
          fprintf(1, 'Motor ID: %d highest temp. limit: %d\n', motor_ids(motor_index), result(motor_index));
        end
      end
    end
    
    % TODO
    % Convert load (to V)
    % positive = ccw, negative = cw
    function result = load_cnt_to_percent( obj, data )
      dir = bitshift(bitand(data, 4096), -10);   % 1 = CW, 0 = CCW
      
      result = bitand(data, 4095)*(0.1).*( (-1).^dir );
    end    
  end
end
